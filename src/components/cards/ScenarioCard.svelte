<script lang="ts">
	import type { WidgetProps } from '$lib/types/widget';
	import { supabase } from '$lib/supabase';
	import type { Database } from '$lib/supabase';
	import { BookOpen, CheckCircle, AlertCircle, ThumbsUp, MessageCircle } from 'lucide-svelte';
	import ComponentErrorBoundary from '$lib/../components/ui/ComponentErrorBoundary.svelte';
	import Loading from '$lib/../components/ui/Loading.svelte';
	import { getUserRole } from '$lib/utils/roles';

	interface Props extends WidgetProps {}

	let { session }: Props = $props();

	// Check if user is a child - only children can see scenarios
	let userRole = $derived(getUserRole(session?.user?.email));
	let isChild = $derived(userRole === 'child');

	let loading = $state(true);
	let submitting = $state(false);
	let error = $state('');
	let questions = $state<Database['public']['Tables']['scenario_questions']['Row'][]>([]);
	let userAnswers = $state<Database['public']['Tables']['scenario_answers']['Row'][]>([]);
	let currentAnswers = $state<{ [questionId: string]: number }>({});
	let showFeedback = $state<{ [questionId: string]: boolean }>({});

	// Get questions that user hasn't answered yet
	let unansweredQuestions = $derived(() => {
		const answeredIds = new Set(userAnswers.map(a => a.question_id));
		return questions.filter(q => !answeredIds.has(q.id));
	});

	// Show first 3 unanswered questions
	let questionsToShow = $derived(() => unansweredQuestions().slice(0, 3));

	// Check if no questions left
	let noQuestionsLeft = $derived(() => unansweredQuestions().length === 0 && questions.length > 0);

	async function loadData() {
		try {
			loading = true;
			error = '';

			// Load scenario questions
			const { data: questionsData, error: questionsError } = await supabase
				.from('scenario_questions')
				.select('*')
				.order('order_index');

			if (questionsError) throw questionsError;
			questions = questionsData || [];

			// Load user's existing answers
			if (session?.user?.id) {
				const { data: answersData, error: answersError } = await supabase
					.from('scenario_answers')
					.select('*')
					.eq('user_id', session.user.id);

				if (answersError) throw answersError;
				userAnswers = answersData || [];
			}

		} catch (err) {
			console.error('Error loading scenario data:', err);
			error = 'Failed to load scenario questions. Please try again.';
		} finally {
			loading = false;
		}
	}

	async function submitAnswer(questionId: string, chosenIndex: number) {
		if (!session?.user?.id) {
			error = 'You must be logged in to submit answers.';
			return;
		}

		try {
			submitting = true;
			error = '';

			const { error: insertError } = await supabase
				.from('scenario_answers')
				.insert({
					user_id: session.user.id,
					question_id: questionId,
					chosen_index: chosenIndex
				});

			if (insertError) throw insertError;

			// Show feedback for this question
			showFeedback[questionId] = true;

			// Add to user answers to update UI
			userAnswers = [...userAnswers, {
				id: '', // Will be generated by DB
				user_id: session.user.id,
				question_id: questionId,
				chosen_index: chosenIndex,
				created_at: new Date().toISOString()
			}];

		} catch (err) {
			console.error('Error submitting answer:', err);
			error = 'Failed to save your answer. Please try again.';
		} finally {
			submitting = false;
		}
	}

	function getQuestionFeedback(question: Database['public']['Tables']['scenario_questions']['Row'], chosenIndex: number) {
		const isCorrect = chosenIndex === question.correct_index;
		
		if (isCorrect) {
			return {
				isCorrect: true,
				title: '👏 Excellent choice!',
				message: `You chose the right option: "${question.options[chosenIndex]}". Great moral reasoning!`
			};
		} else {
			return {
				isCorrect: false,
				title: '💭 Think about this...',
				message: `You chose "${question.options[chosenIndex]}", but the better choice would be "${question.options[question.correct_index]}". Every situation teaches us something new!`
			};
		}
	}

	// Load data on mount
	$effect(() => {
		if (session) {
			loadData();
		}
	});
</script>

<ComponentErrorBoundary componentName="ScenarioCard">
{#if !isChild}
	<!-- Don't render anything for non-children -->
{:else}
<div class="card">
	<div class="flex items-center gap-2 mb-4">
		<BookOpen class="w-6 h-6 text-green-500" aria-hidden="true" />
		<h3 class="text-lg font-semibold text-gray-900">What Would You Do?</h3>
	</div>

	{#if loading}
		<Loading size="md" text="Loading scenarios..." />
	{:else if error}
		<div class="text-center py-8">
			<AlertCircle class="w-12 h-12 text-red-300 mx-auto mb-3" aria-hidden="true" />
			<p class="text-red-600 text-sm mb-3">{error}</p>
			<button 
				onclick={() => loadData()} 
				class="px-4 py-2 text-sm font-medium text-white bg-red-600 hover:bg-red-700 rounded-lg transition-colors"
			>
				Try Again
			</button>
		</div>
	{:else if noQuestionsLeft()}
		<div class="text-center py-8">
			<CheckCircle class="w-12 h-12 text-green-300 mx-auto mb-3" aria-hidden="true" />
			<p class="text-green-600 text-sm font-medium">🎉 No new questions today!</p>
			<p class="text-gray-500 text-sm mt-2">You've completed all available scenarios. Check back later for more!</p>
		</div>
	{:else if questionsToShow().length === 0}
		<div class="text-center py-8">
			<BookOpen class="w-12 h-12 text-gray-300 mx-auto mb-3" aria-hidden="true" />
			<p class="text-gray-500 text-sm">No scenarios available at the moment.</p>
		</div>
	{:else}
		<div class="space-y-6">
			{#each questionsToShow() as question, index (question.id)}
				<div class="bg-gray-50 rounded-lg p-4">
					<h4 class="text-sm font-medium text-gray-900 mb-4">
						Scenario {index + 1}: {question.question_text}
					</h4>

					{#if showFeedback[question.id]}
						<!-- Show feedback after answering -->
						{@const feedback = getQuestionFeedback(question, currentAnswers[question.id])}
						<div class="bg-white rounded-lg p-4 border-2 {feedback.isCorrect ? 'border-green-200 bg-green-50' : 'border-blue-200 bg-blue-50'}">
							<div class="flex items-start gap-3">
								{#if feedback.isCorrect}
									<ThumbsUp class="w-6 h-6 text-green-500 mt-0.5 flex-shrink-0" />
								{:else}
									<MessageCircle class="w-6 h-6 text-blue-500 mt-0.5 flex-shrink-0" />
								{/if}
								<div>
									<h5 class="text-sm font-medium text-gray-900 mb-2">{feedback.title}</h5>
									<p class="text-sm text-gray-700">{feedback.message}</p>
								</div>
							</div>
						</div>
					{:else}
						<!-- Show options for answering -->
						<div class="space-y-3">
							{#each question.options as option, optionIndex (optionIndex)}
								<button
									onclick={() => {
										currentAnswers[question.id] = optionIndex;
										submitAnswer(question.id, optionIndex);
									}}
									disabled={submitting}
									class="w-full text-left p-3 rounded-lg border border-gray-200 hover:border-primary-300 hover:bg-primary-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
								>
									<div class="flex items-start gap-3">
										<span class="w-6 h-6 bg-primary-100 text-primary-600 rounded-full flex items-center justify-center text-xs font-medium flex-shrink-0">
											{String.fromCharCode(65 + optionIndex)}
										</span>
										<span class="text-sm text-gray-700">{option}</span>
									</div>
								</button>
							{/each}
						</div>

						{#if submitting}
							<div class="text-center mt-4">
								<div class="inline-flex items-center gap-2 text-sm text-gray-600">
									<div class="animate-spin rounded-full h-4 w-4 border-b-2 border-primary-600"></div>
									Saving your answer...
								</div>
							</div>
						{/if}
					{/if}
				</div>
			{/each}

			{#if questionsToShow().some(q => showFeedback[q.id])}
				<div class="text-center">
					<button
						onclick={() => {
							// Clear feedback and reload to show more questions
							showFeedback = {};
							loadData();
						}}
						class="px-6 py-2 text-sm font-medium text-primary-600 border border-primary-300 hover:bg-primary-50 rounded-lg transition-colors"
					>
						Continue with more scenarios
					</button>
				</div>
			{/if}
		</div>
	{/if}
</div>
{/if}
</ComponentErrorBoundary>